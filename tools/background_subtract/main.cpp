//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
#include <unistd.h>
//C++
#include <iostream>
#include <sstream>
#include <vector>
#include <thread>

using namespace cv;
using namespace std;

struct MousePoint
{
    size_t x;
    size_t y;

    MousePoint(size_t a, size_t b)
    {
        x = a;
        y = b;
    }

    string ToString()
    {
        stringstream l_ss;
        l_ss << "(" << x << ", " << y << ")";
        return l_ss.str();
    }
};

// GLOBALS
string ORIGINAL_WINDOW_NAME = "Original";
string SUBTRACTED_WINDOW_NAME = "Subtracted";
string MASK_WINDOW_NAME = "Mask";
size_t IMAGE_WIDTH = 400;
size_t IMAGE_HEIGHT = 600;

MousePoint g_mousePosition(0,0);
bool g_isInErasingMode = false;
bool g_isInRestoringMode = false;
bool g_mouseIsDown = false;
cv::Mat g_originalImage;
cv::Mat g_newSubtractedImage;
cv::Mat g_originalSubtractedImage;
cv::Mat g_currentImageMask;
int g_circleRadius = 10;

bool g_killThread = false;

void help();
void processVideo(char* videoFilename);

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bg_sub {-vid <video filename>|-img <image filename>}"                     << endl
    << "for example: ./bg_sub -vid video.avi"                                       << endl
    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main(int argc, char* argv[])
{
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[2]);
    }
    else
    {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void threadFn(
    char* a_videoFilename,
    vector<cv::Mat>& a_frames,
    vector<cv::Mat>& a_imageMasks,
    vector<cv::Mat>& a_backgroundSubtractedImages)
{
    std::cout << "thread function" << endl;
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    //create the capture object
    VideoCapture capture(a_videoFilename);
    if (!capture.isOpened())
    {
        //error in opening the video input
        cerr << "Unable to open video file: " << a_videoFilename << endl;
        return;
    }

    //read input data. ESC or 'q' for quitting
    char keyboard = 0;

    bool l_isFirstImage = true;
    while (true)
    {
        //read the current frame
        Mat frame; //current frame
        Mat fgMask; //fg mask fg mask generated by MOG2 method
        if(!capture.read(frame)) {
            cout << "Done reading frames.." << endl;
            break;
        }

        cv::resize(frame, frame, cv::Size(IMAGE_HEIGHT, IMAGE_WIDTH));
        cv::rotate(frame, frame, cv::ROTATE_90_CLOCKWISE);

        //update the background model
        pMOG2->apply(frame, fgMask);

        // apply mask to subtract background
        cv::Mat bgSubtracted;
        frame.copyTo(bgSubtracted, fgMask);


        if (!l_isFirstImage)
        {
            a_frames.push_back(frame);
            a_imageMasks.push_back(fgMask);
            a_backgroundSubtractedImages.push_back(bgSubtracted);
        }
        l_isFirstImage = false;
        
        // if (frames.size() % 100 == 0)
        // {
        //     cout << "Got frames " << frames.size() << endl;
        // }

        if (g_killThread)
        {
            break;
        }
    }
    //delete capture object
    capture.release();
}

bool processKeyForFrameNum(int& a_frameNum, int a_key, int a_maxFrameNum)
{
    int l_frameNum = a_frameNum;

    if (3 == a_key) // left arrow
    {
        a_frameNum++;
    }
    else if (2 == a_key) // right arrow
    {
        a_frameNum--;
    }
    else if (100 == a_key) // d, +10 frames
    {
        a_frameNum += 10;
    }
    else if (97 == a_key) // a, -10 frames
    {
        a_frameNum -= 10;
    }

    // Make sure we don't overflow
    if (l_frameNum < 0)
    {
        a_frameNum = 0;
    }

    if (l_frameNum >= a_maxFrameNum)
    {
        a_frameNum = a_maxFrameNum - 1;
    }

    return l_frameNum != a_frameNum;
}

void DrawImgWithCircleUnderMouse()
{
    cv::Mat l_imageWithCircle = g_newSubtractedImage.clone();
    if (g_isInRestoringMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,255,0), -1);
    }
    else if (g_isInErasingMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,255), -1);
    }

    imshow(SUBTRACTED_WINDOW_NAME, l_imageWithCircle);
    imshow(MASK_WINDOW_NAME, g_currentImageMask);
}

void UpdateCircleRadius(int a_key)
{
    if (a_key == 43) // '+' increase circle radius
    {
        g_circleRadius++;
        DrawImgWithCircleUnderMouse();
    }

    if (a_key == 95) // '-' increase circle radius
    {
        g_circleRadius--;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius < 0)
    {
        g_circleRadius = 0;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius > 40)
    {
        g_circleRadius = 40;
        DrawImgWithCircleUnderMouse();
    }
}

void UpdateDrawingMode(int a_key)
{
    if (a_key == 101) // 'b' == start erasing
    {
        g_isInErasingMode = true;
        g_isInRestoringMode = false;
    }

    if (a_key == 114) // '=r' == start restoring
    {
        g_isInErasingMode = false;
        g_isInRestoringMode = true;
    }
}

void EraseAreaUnderMouse()
{
    cout << "ERASE AREA UNDER MOUSE!" << endl;

    if (g_isInRestoringMode)
    {
        cv::circle(g_currentImageMask, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(255,255,255), -1);
    }
    else
    {
        cv::circle(g_currentImageMask, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,0), -1);
    }

    cv::Mat l_newBgSubtract;
    g_originalImage.copyTo(l_newBgSubtract, g_currentImageMask);
    g_newSubtractedImage = l_newBgSubtract.clone();
    imshow(SUBTRACTED_WINDOW_NAME, g_newSubtractedImage);
    imshow(MASK_WINDOW_NAME, g_currentImageMask);
}

void MouseCallBackFunc(int event, int x, int y, int flags, void* userdata)
{
    if (event == EVENT_LBUTTONDOWN)
    {
        g_mouseIsDown = true;
        EraseAreaUnderMouse();
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            DrawImgWithCircleUnderMouse();
        }
    }

    if (event == EVENT_LBUTTONUP)
    {
        g_mouseIsDown = false;
    }

    if (event == EVENT_MOUSEMOVE)
    {
        g_mousePosition.x = x;
        g_mousePosition.y = y;
        // cout << "Mouse move over the window - position " << g_mousePosition.ToString() << " isDrawing? " << g_isInErasingMode << endl;
    
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            if (g_mouseIsDown)
            {
                EraseAreaUnderMouse();
            }
            DrawImgWithCircleUnderMouse();
        }
        else
        {
            imshow(SUBTRACTED_WINDOW_NAME, g_originalSubtractedImage);
            imshow(MASK_WINDOW_NAME, g_currentImageMask);
        }
    }
}

void processVideo(char* videoFilename)
{
    vector<cv::Mat> frames;
    vector<cv::Mat> imageMasks;
    vector<cv::Mat> backgroundSubtractedImages;

    std::thread t(threadFn,
        std::ref(videoFilename),
        std::ref(frames),
        std::ref(imageMasks),
        std::ref(backgroundSubtractedImages));
    std::cout << "main thread\n";

    size_t l_numFrames = 100;

    while (frames.size() < l_numFrames) {
        // cout << "waiting for 100 frames" << endl;
        usleep(100000);
    }

    cout << "Got " << l_numFrames << " frames!" << endl;

    //create GUI windows
    namedWindow(ORIGINAL_WINDOW_NAME);
    namedWindow(SUBTRACTED_WINDOW_NAME);

    setMouseCallback(SUBTRACTED_WINDOW_NAME, MouseCallBackFunc, NULL);

    int l_frameNum = 0;
    g_originalImage = frames.at(l_frameNum).clone();
    g_currentImageMask = imageMasks.at(l_frameNum).clone();
    g_originalSubtractedImage = backgroundSubtractedImages.at(l_frameNum).clone();
    g_newSubtractedImage = backgroundSubtractedImages.at(l_frameNum).clone();

    // show the current frame and the fg masks
    imshow(ORIGINAL_WINDOW_NAME, g_originalImage);
    imshow(SUBTRACTED_WINDOW_NAME, g_newSubtractedImage);
    imshow(MASK_WINDOW_NAME, g_currentImageMask);

    while (l_frameNum < frames.size())
    {
        int l_key = waitKey();
        cout << l_key << endl;
        if (processKeyForFrameNum(l_frameNum, l_key, frames.size()))
        {
            cout << "Getting image at: " << l_frameNum << endl;
            g_originalImage = frames.at(l_frameNum).clone();
            g_currentImageMask = imageMasks.at(l_frameNum).clone();
            g_originalSubtractedImage = backgroundSubtractedImages.at(l_frameNum).clone();
            g_newSubtractedImage = backgroundSubtractedImages.at(l_frameNum).clone();

            // get the frame number and write it on the current frame
            // stringstream ss;
            // rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
            //           cv::Scalar(255,255,255), -1);
            // ss << l_frameNum;
            // string frameNumberString = ss.str();
            // putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            //         FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

            //show the current frame and the fg masks
            imshow(ORIGINAL_WINDOW_NAME, g_originalImage);
            imshow(SUBTRACTED_WINDOW_NAME, g_newSubtractedImage);
            imshow(MASK_WINDOW_NAME, g_currentImageMask);
        }

        UpdateDrawingMode(l_key);
        UpdateCircleRadius(l_key);

        if (l_key == 113 || l_key == 27) // quit if 'q' or 'esc'
        {
            g_killThread = true;
            break;
        }
    }

    t.join();
}
