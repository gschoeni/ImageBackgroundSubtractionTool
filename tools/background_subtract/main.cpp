//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
#include <unistd.h>
//C++
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <thread>

using namespace cv;
using namespace std;

struct MousePoint
{
    size_t x;
    size_t y;

    MousePoint(size_t a, size_t b)
    {
        x = a;
        y = b;
    }

    string ToString()
    {
        stringstream l_ss;
        l_ss << "(" << x << ", " << y << ")";
        return l_ss.str();
    }
};

// GLOBALS
string ORIGINAL_WINDOW_NAME = "Original";
string SUBTRACTED_WINDOW_NAME = "Subtracted";
string MASK_WINDOW_NAME = "Mask";
string OUTPUT_DIR = "originals/";
string MASK_FILE_PREFIX = "mask_original_";
size_t IMAGE_WIDTH = 342;
size_t IMAGE_HEIGHT = 512;

MousePoint g_mousePosition(0,0);
bool g_isInErasingMode = false;
bool g_isInRestoringMode = false;
bool g_mouseIsDown = false;
vector<cv::Mat> g_originalImages;
vector<cv::Mat> g_backgroundSubtractedImages;
vector<cv::Mat> g_imageMasks;
int g_currentFrame = 0;
int g_circleRadius = 10;

bool g_killThread = false;

void help();
void processVideo(char* videoFilename);

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bg_sub {-vid <video filename>|-img <image filename>}"                     << endl
    << "for example: ./bg_sub -vid video.avi"                                       << endl
    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main(int argc, char* argv[])
{
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[2]);
    }
    else
    {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

inline bool fileExists (const std::string& name) {
    ifstream f(name.c_str());
    return f.good();
}

void threadFn(char* a_videoFilename)
{
    std::cout << "thread function" << endl;
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    //create the capture object
    VideoCapture capture(a_videoFilename);
    if (!capture.isOpened())
    {
        //error in opening the video input
        cerr << "Unable to open video file: " << a_videoFilename << endl;
        return;
    }

    //read input data. ESC or 'q' for quitting
    char keyboard = 0;

    bool l_isFirstImage = true;
    while (true)
    {
        //read the current frame
        Mat frame; //current frame
        Mat fgMask; //fg mask fg mask generated by MOG2 method
        if(!capture.read(frame)) {
            cout << "Done reading frames.." << endl;
            break;
        }

        cv::resize(frame, frame, cv::Size(IMAGE_HEIGHT, IMAGE_WIDTH));
        cv::rotate(frame, frame, cv::ROTATE_90_CLOCKWISE);

        // update the background model
        pMOG2->apply(frame, fgMask);

        if (!l_isFirstImage)
        {
            g_originalImages.push_back(frame);
            g_imageMasks.push_back(fgMask);

            cv::Mat bgSubtracted;

            size_t l_frameNum = g_imageMasks.size()-1;
            stringstream l_ss;
            l_ss << OUTPUT_DIR << MASK_FILE_PREFIX << l_frameNum << ".png";
            string l_maskFileName = l_ss.str();
            if (fileExists(l_maskFileName))
            {
                cv::Mat l_mask = cv::imread(l_maskFileName);
                g_imageMasks.at(l_frameNum) = l_mask;
                frame.copyTo(bgSubtracted, l_mask);
            }
            else
            {
                // apply mask to subtract background
                frame.copyTo(bgSubtracted, fgMask);
            }

            g_backgroundSubtractedImages.push_back(bgSubtracted);
        }
        l_isFirstImage = false;
        
        // if (frames.size() % 100 == 0)
        // {
        //     cout << "Got frames " << frames.size() << endl;
        // }

        if (g_killThread)
        {
            break;
        }
    }
    //delete capture object
    capture.release();
}

bool processKeyForFrameNum(int a_key, int a_maxFrameNum)
{
    int l_frameNum = g_currentFrame;

    if (3 == a_key) // left arrow
    {
        g_currentFrame++;
    }
    else if (2 == a_key) // right arrow
    {
        g_currentFrame--;
    }
    else if (100 == a_key) // d, +10 frames
    {
        g_currentFrame += 10;
    }
    else if (97 == a_key) // a, -10 frames
    {
        g_currentFrame -= 10;
    }

    // Make sure we don't overflow
    if (l_frameNum < 0)
    {
        g_currentFrame = 0;
    }

    if (l_frameNum >= a_maxFrameNum)
    {
        g_currentFrame = a_maxFrameNum - 1;
    }

    return l_frameNum != g_currentFrame;
}

void DrawImgWithCircleUnderMouse()
{
    cv::Mat l_imageWithCircle = g_backgroundSubtractedImages.at(g_currentFrame).clone();
    if (g_isInRestoringMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,255,0), -1);
    }
    else if (g_isInErasingMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,255), -1);
    }

    imshow(SUBTRACTED_WINDOW_NAME, l_imageWithCircle);
    imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));
}

void UpdateCircleRadius(int a_key)
{
    if (a_key == 43) // '+' increase circle radius
    {
        g_circleRadius++;
        DrawImgWithCircleUnderMouse();
    }

    if (a_key == 95) // '-' increase circle radius
    {
        g_circleRadius--;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius < 0)
    {
        g_circleRadius = 0;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius > 40)
    {
        g_circleRadius = 40;
        DrawImgWithCircleUnderMouse();
    }
}

void UpdateDrawingMode(int a_key)
{
    if (a_key == 101) // 'b' == start erasing
    {
        g_isInErasingMode = true;
        g_isInRestoringMode = false;
    }

    if (a_key == 114) // '=r' == start restoring
    {
        g_isInErasingMode = false;
        g_isInRestoringMode = true;
    }
}

void EraseAreaUnderMouse()
{
    // cout << "ERASE AREA UNDER MOUSE!" << endl;

    if (g_isInRestoringMode)
    {
        cv::circle(g_imageMasks.at(g_currentFrame) , cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(255,255,255), -1);
    }
    else
    {
        cv::circle(g_imageMasks.at(g_currentFrame) , cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,0), -1);
    }

    cv::Mat l_newBgSubtract;
    g_originalImages.at(g_currentFrame).copyTo(l_newBgSubtract, g_imageMasks.at(g_currentFrame) );
    g_backgroundSubtractedImages.at(g_currentFrame) = l_newBgSubtract.clone();
    imshow(SUBTRACTED_WINDOW_NAME, g_backgroundSubtractedImages.at(g_currentFrame));
    imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame) );
}

void MouseCallBackFunc(int event, int x, int y, int flags, void* userdata)
{
    if (event == EVENT_LBUTTONDOWN)
    {
        g_mouseIsDown = true;
        EraseAreaUnderMouse();
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            DrawImgWithCircleUnderMouse();
        }
    }

    if (event == EVENT_LBUTTONUP)
    {
        g_mouseIsDown = false;
    }

    if (event == EVENT_MOUSEMOVE)
    {
        g_mousePosition.x = x;
        g_mousePosition.y = y;
        // cout << "Mouse move over the window - position " << g_mousePosition.ToString() << " isDrawing? " << g_isInErasingMode << endl;
    
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            if (g_mouseIsDown)
            {
                EraseAreaUnderMouse();
            }
            DrawImgWithCircleUnderMouse();
        }
        else
        {
            imshow(SUBTRACTED_WINDOW_NAME, g_backgroundSubtractedImages.at(g_currentFrame));
            imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));
        }
    }
}

void MaybeSave(int a_key)
{
    if (a_key == 115) // 's'
    {
        cout << "Writing image " << g_currentFrame << " to " << g_currentFrame << endl;
        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << "original_" << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_originalImages.at(g_currentFrame));
        }
        
        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << "nobg_" << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_backgroundSubtractedImages.at(g_currentFrame));
        }

        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << MASK_FILE_PREFIX << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_imageMasks.at(g_currentFrame) );
        }
    }
}

void processVideo(char* videoFilename)
{
    std::thread t(threadFn, std::ref(videoFilename));
    std::cout << "main thread\n";

    size_t l_numFrames = 100;

    while (g_originalImages.size() < l_numFrames) {
        // cout << "waiting for 100 frames" << endl;
        usleep(100000);
    }

    cout << "Got " << l_numFrames << " frames!" << endl;

    //create GUI windows
    namedWindow(ORIGINAL_WINDOW_NAME);
    namedWindow(SUBTRACTED_WINDOW_NAME);

    setMouseCallback(SUBTRACTED_WINDOW_NAME, MouseCallBackFunc, NULL);

    // show the current frame and the fg masks
    imshow(ORIGINAL_WINDOW_NAME, g_originalImages.at(g_currentFrame));
    imshow(SUBTRACTED_WINDOW_NAME, g_backgroundSubtractedImages.at(g_currentFrame));
    imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));

    while (g_currentFrame < g_originalImages.size())
    {
        int l_key = waitKey();
        cout << l_key << endl;
        if (processKeyForFrameNum(l_key, g_originalImages.size()))
        {
            cout << "Getting image at: " << g_currentFrame << endl;

            // get the frame number and write it on the current frame
            // stringstream ss;
            // rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
            //           cv::Scalar(255,255,255), -1);
            // ss << g_currentFrame;
            // string frameNumberString = ss.str();
            // putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            //         FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

            //show the current frame and the fg masks
            imshow(ORIGINAL_WINDOW_NAME, g_originalImages.at(g_currentFrame));
            imshow(SUBTRACTED_WINDOW_NAME, g_backgroundSubtractedImages.at(g_currentFrame));
            imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));
        }

        UpdateDrawingMode(l_key);
        UpdateCircleRadius(l_key);
        MaybeSave(l_key);

        if (l_key == 113 || l_key == 27) // quit if 'q' or 'esc'
        {
            g_killThread = true;
            break;
        }
    }

    t.join();
}
