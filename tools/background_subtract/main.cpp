//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/opencv.hpp>
//C
#include <stdio.h>
#include <unistd.h>
//C++
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <thread>

using namespace cv;
using namespace std;

struct MousePoint
{
    size_t x;
    size_t y;

    MousePoint(size_t a, size_t b)
    {
        x = a;
        y = b;
    }

    string ToString()
    {
        stringstream l_ss;
        l_ss << "(" << x << ", " << y << ")";
        return l_ss.str();
    }
};

// GLOBALS
string ORIGINAL_WINDOW_NAME = "Original";
string SUBTRACTED_WINDOW_NAME = "Subtracted";
string MASK_WINDOW_NAME = "Mask";
string OUTPUT_DIR = "originals/";
string MASK_FILE_PREFIX = "mask_original_";
size_t IMAGE_WIDTH = 342;
size_t IMAGE_HEIGHT = 512;

MousePoint g_mousePosition(0,0);
bool g_isInErasingMode = false;
bool g_isInRestoringMode = false;
bool g_mouseIsDown = false;
vector<cv::Mat> g_originalImages;
vector<cv::Mat> g_backgroundSubtractedImages;
vector<cv::Mat> g_imageMasks;
int g_currentFrame = 0;
int g_circleRadius = 10;
cv::Rect g_grabCutRectangle;
cv::Mat g_grabCutBGModel, g_grabCutFGModel; // the models (internally used)
bool g_grabCutIsInitialized = false;

bool g_killThread = false;

void help();
void processVideo(char* videoFilename);

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bg_sub {-vid <video filename>|-img <image filename>}"                     << endl
    << "for example: ./bg_sub -vid video.avi"                                       << endl
    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main(int argc, char* argv[])
{
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[2]);
    }
    else
    {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

inline bool fileExists (const std::string& name) {
    ifstream f(name.c_str());
    return f.good();
}

void threadFn(char* a_videoFilename)
{
    std::cout << "thread function" << endl;
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    //create the capture object
    VideoCapture capture(a_videoFilename);
    if (!capture.isOpened())
    {
        //error in opening the video input
        cerr << "Unable to open video file: " << a_videoFilename << endl;
        return;
    }

    //read input data. ESC or 'q' for quitting
    char keyboard = 0;

    bool l_isFirstImage = true;
    while (true)
    {
        //read the current frame
        Mat frame; //current frame
        Mat fgMask; //fg mask fg mask generated by MOG2 method
        if(!capture.read(frame)) {
            cout << "Done reading frames.." << endl;
            break;
        }

        cv::resize(frame, frame, cv::Size(IMAGE_HEIGHT, IMAGE_WIDTH));
        cv::rotate(frame, frame, cv::ROTATE_90_CLOCKWISE);

        // update the background model
        pMOG2->apply(frame, fgMask);

        if (!l_isFirstImage)
        {
            g_originalImages.push_back(frame);
            g_imageMasks.push_back(fgMask);

            cv::Mat bgSubtracted;

            size_t l_frameNum = g_imageMasks.size()-1;
            stringstream l_ss;
            l_ss << OUTPUT_DIR << MASK_FILE_PREFIX << l_frameNum << ".png";
            string l_maskFileName = l_ss.str();
            if (fileExists(l_maskFileName))
            {
                cv::Mat l_mask = cv::imread(l_maskFileName, cv::IMREAD_GRAYSCALE);
                g_imageMasks.at(l_frameNum) = l_mask;
                frame.copyTo(bgSubtracted, l_mask);
            }
            else
            {
                // apply mask to subtract background
                frame.copyTo(bgSubtracted, fgMask);
            }

            g_backgroundSubtractedImages.push_back(bgSubtracted);
        }
        l_isFirstImage = false;
        
        // if (frames.size() % 100 == 0)
        // {
        //     cout << "Got frames " << frames.size() << endl;
        // }

        if (g_killThread)
        {
            break;
        }
    }
    //delete capture object
    capture.release();
}

static void getBinMask( const Mat& comMask, Mat& binMask )
{
    if( comMask.empty() || comMask.type()!=CV_8UC1 )
        CV_Error( Error::StsBadArg, "comMask is empty or has incorrect type (not CV_8UC1)" );
    if( binMask.empty() || binMask.rows!=comMask.rows || binMask.cols!=comMask.cols )
        binMask.create( comMask.size(), CV_8UC1 );
    binMask = comMask & 1;
}

bool hasNeighboringWhitePixel(const cv::Mat& a_mat, size_t i, size_t j)
{
    if (i < a_mat.rows - 1)
    {
        uchar l_rgb = a_mat.at<uchar>(i+1,j);
        if (l_rgb == 255)
        {
            return true;
        }
    }

    if (i > 0)
    {
        uchar l_rgb = a_mat.at<uchar>(i-1,j);
        if (l_rgb == 255)
        {
            return true;
        }
    }

    if (i < a_mat.cols - 1)
    {
        uchar l_rgb = a_mat.at<uchar>(i,j+1);
        if (l_rgb == 255)
        {
            return true;
        }
    }

    if (j > 0)
    {
        uchar l_rgb = a_mat.at<uchar>(i,j-1);
        if (l_rgb == 255)
        {
            return true;
        }
    }
    return false;
}

size_t FindMaskMinX()
{
    cv::Mat l_mask = g_imageMasks.at(g_currentFrame);
    size_t l_min = l_mask.cols;
    for (size_t i = 0; i < l_mask.rows; ++i)
    {
        for (size_t j = 0; j < l_mask.cols; ++j)
        {
            uchar l_rgb = l_mask.at<uchar>(i,j);
            if (l_rgb == 255 && hasNeighboringWhitePixel(l_mask, i, j))
            {
                if (j < l_min)
                {
                    l_min = j;
                }
            }
        }
    }

    return l_min;
}

size_t FindMaskMinY()
{
    cv::Mat l_mask = g_imageMasks.at(g_currentFrame);
    size_t l_min = l_mask.rows;
    for (size_t i = 0; i < l_mask.rows; ++i)
    {
        for (size_t j = 0; j < l_mask.cols; ++j)
        {
            uchar l_rgb = l_mask.at<uchar>(i,j);
            if (l_rgb == 255 && hasNeighboringWhitePixel(l_mask, i, j))
            {
                if (i < l_min)
                {
                    l_min = i;
                }
            }
        }
    }

    return l_min;
}

size_t FindMaskMaxX()
{
    size_t l_max = 0;
    cv::Mat l_mask = g_imageMasks.at(g_currentFrame);
    for (size_t i = 0; i < l_mask.rows; ++i)
    {
        for (size_t j = 0; j < l_mask.cols; ++j)
        {
            uchar l_rgb = l_mask.at<uchar>(i,j);
            if (l_rgb == 255 && hasNeighboringWhitePixel(l_mask, i, j))
            {
                if (j > l_max)
                {
                    l_max = j;
                }
            }
        }
    }

    return l_max;
}

size_t FindMaskMaxY()
{
    size_t l_max = 0;
    cv::Mat l_mask = g_imageMasks.at(g_currentFrame);
    for (size_t i = 0; i < l_mask.rows; ++i)
    {
        for (size_t j = 0; j < l_mask.cols; ++j)
        {
            uchar l_rgb = l_mask.at<uchar>(i,j);
            if (l_rgb == 255 && hasNeighboringWhitePixel(l_mask, i, j))
            {
                if (i > l_max)
                {
                    l_max = i;
                }
            }
        }
    }

    return l_max;
}

void ConvertBinaryTo255(cv::Mat& a_mat)
{
    for (size_t i = 0; i < a_mat.rows; ++i)
    {
        for (size_t j = 0; j < a_mat.cols; ++j)
        {
            if (1 == a_mat.at<uchar>(i,j))
            {
                a_mat.at<uchar>(i,j) = 255;
            }
        }
    }
}

void DrawGrabcutRectangle()
{
    size_t l_minX = FindMaskMinX();
    size_t l_minY = FindMaskMinY();
    size_t l_maxX = FindMaskMaxX();
    size_t l_maxY = FindMaskMaxY();

    cout << "Got rect " << l_minX << ", " << l_minY << ", " << l_maxX << ", " << l_maxY << endl;

    g_grabCutRectangle.x = l_minX;
    g_grabCutRectangle.y = l_minY;
    g_grabCutRectangle.width = l_maxX-l_minX;
    g_grabCutRectangle.height = l_maxY-l_minY;

    cv::rectangle(g_backgroundSubtractedImages.at(g_currentFrame), g_grabCutRectangle, cv::Scalar(0,255,0),1);
}

bool isOutsideRect(const cv::Rect& a_rect, size_t i, size_t j)
{
    if (j < (a_rect.x + (.5*a_rect.width)) && j > (a_rect.x - (.5*a_rect.width)) &&
        i < (a_rect.y + (.5*a_rect.height)) && i > (a_rect.y - (.5*a_rect.height)))
    {
        return false; // is inside rect
    }

    return true; // is outside rct
}

void ShowImages()
{
    // DrawGrabcutRectangle();

    // show the current frame and the fg masks
    imshow(ORIGINAL_WINDOW_NAME, g_originalImages.at(g_currentFrame));
    imshow(SUBTRACTED_WINDOW_NAME, g_backgroundSubtractedImages.at(g_currentFrame));
    imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));
}

void ShowImagesWithTmpBGImage(const cv::Mat& a_img)
{
    // DrawGrabcutRectangle();

    // show the current frame and the fg masks
    imshow(ORIGINAL_WINDOW_NAME, g_originalImages.at(g_currentFrame));
    imshow(SUBTRACTED_WINDOW_NAME, a_img);
    imshow(MASK_WINDOW_NAME, g_imageMasks.at(g_currentFrame));
}

void ApplyGrabCut()
{
    cout << "ApplyGrabCut!" << endl;

    size_t l_minX = FindMaskMinX();
    size_t l_minY = FindMaskMinY();
    size_t l_maxX = FindMaskMaxX();
    size_t l_maxY = FindMaskMaxY();

    g_grabCutRectangle.x = l_minX;
    g_grabCutRectangle.y = l_minY;
    g_grabCutRectangle.width = l_maxX-l_minX;
    g_grabCutRectangle.height = l_maxY-l_minY;

    cv::Mat l_mask = g_imageMasks.at(g_currentFrame).clone();
    for (size_t i = 0; i < l_mask.rows; ++i)
    {
        for (size_t j = 0; j < l_mask.cols; ++j)
        {
            if (l_mask.at<uchar>(i,j) == 255)
            {
                l_mask.at<uchar>(i,j) = GC_PR_FGD;
            }
            else
            {
                l_mask.at<uchar>(i,j) = GC_PR_BGD;
            }
        }
    }

    // GrabCut segmentation
    if (g_grabCutIsInitialized)
    {
        cv::grabCut(g_originalImages.at(g_currentFrame),    // input image
                l_mask,   // segmentation result
                g_grabCutRectangle,// rectangle containing foreground
                g_grabCutBGModel, g_grabCutFGModel, // models
                1);        // number of iterations
    }
    else
    {
        cv::grabCut(g_originalImages.at(g_currentFrame),    // input image
                l_mask,   // segmentation result
                g_grabCutRectangle,// rectangle containing foreground
                g_grabCutBGModel, g_grabCutFGModel, // models
                1,        // number of iterations
                cv::GC_INIT_WITH_RECT | cv::GC_INIT_WITH_MASK); // use rectangle
    }
    

    // for (size_t i = 0; i < l_mask.rows; ++i)
    // {
    //     for (size_t j = 0; j < l_mask.cols; ++j)
    //     {
    //         if (l_mask.at<uchar>(i,j) == GC_FGD)
    //         {
    //             g_imageMasks.at(g_currentFrame).at<uchar>(i,j) = 255;
    //         }
    //         else
    //         {
    //             g_imageMasks.at(g_currentFrame).at<uchar>(i,j) = 0;
    //         }
    //     }
    // }

    cv::Mat l_binMask;
    getBinMask(l_mask, l_binMask);

    cv::Mat l_combined;
    cv::bitwise_and(l_binMask, g_imageMasks.at(g_currentFrame), l_combined);

    cv::Mat l_combinedSubtracted;
    g_originalImages.at(g_currentFrame).copyTo(l_combinedSubtracted, l_combined);
    g_backgroundSubtractedImages.at(g_currentFrame) = l_combinedSubtracted.clone();

    ConvertBinaryTo255(l_combined);
    g_imageMasks.at(g_currentFrame) = l_combined.clone();

    // cv::Mat l_grabCutSubtracted;
    // g_originalImages.at(g_currentFrame).copyTo(l_grabCutSubtracted, binMask);

    // cv::Mat l_nnSubtracted;
    // l_grabCutSubtracted.copyTo(l_nnSubtracted, g_imageMasks.at(g_currentFrame));

    // g_backgroundSubtractedImages.at(g_currentFrame) = l_nnSubtracted.clone();
    ShowImages();
}

bool processKeyForFrameNum(int a_key, int a_maxFrameNum)
{
    int l_frameNum = g_currentFrame;

    if (3 == a_key) // left arrow
    {
        g_currentFrame++;
    }
    else if (2 == a_key) // right arrow
    {
        g_currentFrame--;
    }
    else if (100 == a_key) // d, +10 frames
    {
        g_currentFrame += 10;
    }
    else if (97 == a_key) // a, -10 frames
    {
        g_currentFrame -= 10;
    }

    // Make sure we don't overflow
    if (l_frameNum < 0)
    {
        g_currentFrame = 0;
    }

    if (l_frameNum >= a_maxFrameNum)
    {
        g_currentFrame = a_maxFrameNum - 1;
    }

    return l_frameNum != g_currentFrame;
}

void DrawImgWithCircleUnderMouse()
{
    cv::Mat l_imageWithCircle = g_backgroundSubtractedImages.at(g_currentFrame).clone();
    if (g_isInRestoringMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,255,0), -1);
    }
    else if (g_isInErasingMode)
    {
        cv::circle(l_imageWithCircle, cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,255), -1);
    }

    ShowImagesWithTmpBGImage(l_imageWithCircle);
}

void UpdateCircleRadius(int a_key)
{
    if (a_key == 43) // '+' increase circle radius
    {
        g_circleRadius++;
        DrawImgWithCircleUnderMouse();
    }

    if (a_key == 95) // '-' increase circle radius
    {
        g_circleRadius--;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius < 0)
    {
        g_circleRadius = 0;
        DrawImgWithCircleUnderMouse();
    }

    if (g_circleRadius > 40)
    {
        g_circleRadius = 40;
        DrawImgWithCircleUnderMouse();
    }
}

void UpdateDrawingMode(int a_key)
{
    if (a_key == 101) // 'b' == start erasing
    {
        g_isInErasingMode = true;
        g_isInRestoringMode = false;
    }

    if (a_key == 114) // '=r' == start restoring
    {
        g_isInErasingMode = false;
        g_isInRestoringMode = true;
    }
}

void EraseAreaUnderMouse()
{
    // cout << "ERASE AREA UNDER MOUSE!" << endl;

    if (g_isInRestoringMode)
    {
        cv::circle(g_imageMasks.at(g_currentFrame) , cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(255,255,255), -1);
    }
    else
    {
        cv::circle(g_imageMasks.at(g_currentFrame) , cv::Point(g_mousePosition.x, g_mousePosition.y), g_circleRadius, cv::Scalar(0,0,0), -1);
    }

    cv::Mat l_newBgSubtract;
    g_originalImages.at(g_currentFrame).copyTo(l_newBgSubtract, g_imageMasks.at(g_currentFrame));
    g_backgroundSubtractedImages.at(g_currentFrame) = l_newBgSubtract.clone();

    ShowImages();
}

void MouseCallBackFunc(int event, int x, int y, int flags, void* userdata)
{
    if (event == EVENT_LBUTTONDOWN)
    {
        g_mouseIsDown = true;
        EraseAreaUnderMouse();
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            DrawImgWithCircleUnderMouse();
        }
    }

    if (event == EVENT_LBUTTONUP)
    {
        g_mouseIsDown = false;
    }

    if (event == EVENT_MOUSEMOVE)
    {
        g_mousePosition.x = x;
        g_mousePosition.y = y;
        // cout << "Mouse move over the window - position " << g_mousePosition.ToString() << " isDrawing? " << g_isInErasingMode << endl;
    
        if (g_isInErasingMode || g_isInRestoringMode)
        {
            if (g_mouseIsDown)
            {
                EraseAreaUnderMouse();
            }
            DrawImgWithCircleUnderMouse();
        }
        else
        {
            ShowImages();
        }
    }
}

void MaybeSave(int a_key)
{
    if (a_key == 115) // 's'
    {
        cout << "Writing image " << g_currentFrame << " to " << g_currentFrame << endl;
        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << "original_" << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_originalImages.at(g_currentFrame));
        }
        
        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << "nobg_" << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_backgroundSubtractedImages.at(g_currentFrame));
        }

        {
            stringstream l_ss;
            l_ss << OUTPUT_DIR << MASK_FILE_PREFIX << g_currentFrame << ".png";
            cv::imwrite(l_ss.str(), g_imageMasks.at(g_currentFrame) );
        }
    }
}

void CheckForApplyGrabCut(int a_key)
{
    if (99 == a_key) // 'c' == key
    {
        ApplyGrabCut();
    }
}

void processVideo(char* videoFilename)
{
    std::thread t(threadFn, std::ref(videoFilename));
    std::cout << "main thread\n";

    size_t l_numFrames = 280;

    while (g_originalImages.size() < l_numFrames) {
        // cout << "waiting for 100 frames" << endl;
        usleep(100000);
    }

    cout << "Got " << l_numFrames << " frames!" << endl;

    //create GUI windows
    namedWindow(ORIGINAL_WINDOW_NAME);
    namedWindow(SUBTRACTED_WINDOW_NAME);

    setMouseCallback(SUBTRACTED_WINDOW_NAME, MouseCallBackFunc, NULL);

    // show the current frame and the fg masks
    g_currentFrame = l_numFrames;

    g_grabCutIsInitialized = false;
    ShowImages();

    while (g_currentFrame < g_originalImages.size())
    {
        int l_key = waitKey();
        cout << l_key << endl;
        if (processKeyForFrameNum(l_key, g_originalImages.size()))
        {
            cout << "Getting image at: " << g_currentFrame << endl;

            // get the frame number and write it on the current frame
            // stringstream ss;
            // rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
            //           cv::Scalar(255,255,255), -1);
            // ss << g_currentFrame;
            // string frameNumberString = ss.str();
            // putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            //         FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

            g_grabCutIsInitialized = false;
            ShowImages();
        }

        CheckForApplyGrabCut(l_key);
        UpdateDrawingMode(l_key);
        UpdateCircleRadius(l_key);
        MaybeSave(l_key);

        if (l_key == 113 || l_key == 27) // quit if 'q' or 'esc'
        {
            g_killThread = true;
            break;
        }
    }

    t.join();
}
